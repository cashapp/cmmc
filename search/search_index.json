{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CMMC","text":"<p>ConfigMap Merging Controller (cmmc) is a Kubernetes operator that allows for the combination of ConfigMap resources.</p>"},{"location":"#why","title":"Why?","text":"<p>The impetus for building this is to have a GitOps friendly solution to manage <code>kube-system/aws-auth</code>, a ConfigMap that binds AWS roles to K8S Roles in EKS. Instead of solving the problem directly, the approach was to ask the question: If another tool existed that would make this problem trivial to solve that wasn't just for this specific use-case what would it be?</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Watch specific keys of ConfigMaps and merge their results into a target ConfigMap.</li> <li>Changes to existing resource state are non-destructive and recoverable.</li> <li>JSONSchema validation capability to ensure that an invalid ConfigMap cannot be written.</li> <li>Permissions optionally gated by namespace selectors.</li> <li>Fully Configurable source/target selectors mix and match.</li> <li>Metrics exposed for how many resources are being watched/updated, and their reconcile states.</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>See contributing docs.</p>"},{"location":"#license","title":"License","text":"<p>Apache Licnese 2.0</p>"},{"location":"architecture/","title":"Architecture","text":"<p>TODO</p>"},{"location":"contributing/","title":"Contributing","text":"<p>The operator is built on the kubebuilder library and has two controllers/reconcilers, one for the <code>MergeSource</code> resource and one for <code>MergeTarget</code>, if you haven't gone through the book, there are some very useful examples for how to get an operator running locally.</p>"},{"location":"contributing/#requirements","title":"Requirements","text":"<ul> <li>Hermit. The library uses hermit for local dependency management,    see installation instructions.</li> <li>Docker / Kubernetes.  You'll generally need <code>docker</code> installed and have    a k8s cluster available for testing and iteration.</li> </ul>"},{"location":"contributing/#running-locally","title":"Running Locally","text":"<p>Once you have the repo which you can either clone directly, or fork.</p> <pre><code>cd path/to/cmmc\n</code></pre> <p>If hermit is installed with the environment detection you should immediately see a hermit environment prompt.</p> <pre><code># generate the CRDs and install them into the current kubernetes cluster\nmake install\n\n# run the operator locally against the kubernetes cluster\nmake run\n\n# to run automated tests\nmake test\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>To run a development version of the documentation server.</p> <pre><code>make mkdocs-serve\n</code></pre>"},{"location":"contributing/#the-makefile","title":"The <code>Makefile</code>","text":"<pre><code>make help\n\nUsage:\n  make &lt;target&gt;\n\nGeneral\n  help             Display this help.\n\nDevelopment\n  manifests        Generate WebhookConfiguration, ClusterRole and CustomResourceDefinition objects.\n  generate         Generate code containing DeepCopy, DeepCopyInto, and DeepCopyObject method implementations.\n  fmt              Run go fmt against code.\n  vet              Run go vet against code.\n  lint             Run golangci-lint against the code.\n  mkdocs-serve     Run mkdocs-material dev server in docker.\n  test             Run tests.\n\nBuild\n  build            Build manager binary.\n  run              Run a controller from your host.\n  docker-build     Build docker image with the manager.\n  docker-push      Push docker image with the manager.\n\nCI\n  diff-check       Checks to see if there are any changes in git\n\nDeployment\n  install          Install CRDs into the K8s cluster specified in ~/.kube/config.\n  uninstall        Uninstall CRDs from the K8s cluster specified in ~/.kube/config.\n  deploy           Deploy controller to the K8s cluster specified in ~/.kube/config.\n  undeploy         Undeploy controller from the K8s cluster specified in ~/.kube/config.\n  controller-gen   Download controller-gen locally if necessary.\n  kustomize        Download kustomize locally if necessary.\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>Info</p> <p>Be sure to use the correct version of the operator and the resources!</p>"},{"location":"usage/#installation","title":"Installation","text":"<p>A very basic install of the operator involves installing the CRDs, the permissions for the CMMC ServiceAccount to be able to watch and modify ConfigMaps, and the controller manager itself.</p> <ul> <li>All of these Kustomization resources are located in the <code>config/</code> directory.</li> <li>Each release of cmmc is also pushed   to dockerhub.</li> </ul> <pre><code>apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\n\nnamespace: cmmc-system\nnamePrefix: cmmc-\n\nimages:\n- name: controller\n  newName: cashapp/cmmc\n  newTag: SOME_VERSION\n\nresources:\n- path/to/config/crd\n- path/to/config/rbac\n- path/to/config/manager\n</code></pre>"},{"location":"usage/#customizing-arguments","title":"Customizing Arguments","text":"<p>By default (if you're using the above kustomization), <code>cmmc</code> runs with the <code>--leader-select</code> flag. You can check <code>main.go</code> for available args or run <code>go run ./ --help</code>.</p> <pre><code>Usage of cmmc:\n  -health-probe-bind-address string\n        The address the probe endpoint binds to. (default \":8081\")\n  -help\n        Display usage\n  -kubeconfig string\n        Paths to a kubeconfig. Only required if out-of-cluster.\n  -leader-elect\n        Enable leader election for controller manager. Enabling this will ensure there is only one active controller manager.\n  -merge-source-max-concurrent-reconciles int\n        MergeSourceController - MaxConcurrentReconciles (default 1)\n  -merge-target-max-concurrent-reconciles int\n        MergeTargetController - MaxConcurrentReconciles (default 1)\n  -metrics-bind-address string\n        The address the metric endpoint binds to. (default \":8080\")\n  -zap-devel\n        Development Mode defaults(encoder=consoleEncoder,logLevel=Debug,stackTraceLevel=Warn). Production Mode defaults(encoder=jsonEncoder,logLevel=Info,stackTraceLevel=Error) (default true)\n  -zap-encoder value\n        Zap log encoding (one of 'json' or 'console')\n  -zap-log-level value\n        Zap Level to configure the verbosity of logging. Can be one of 'debug', 'info', 'error', or any integer value &gt; 0 which corresponds to custom debug levels of increasing verbosity\n  -zap-stacktrace-level value\n        Zap Level at and above which stacktraces are captured (one of 'info', 'error', 'panic').\n</code></pre> <p>You can override any arguments by providing patches to the configuration above:</p> <pre><code>patches:\n- patch: |-\n    - op: replace\n      path: /spec/template/spec/containers/0/args\n      value: [\n        \"--leader-select\",\n        \"--merge-target-max-concurrent-reconciles\", \"1\",\n        \"--merge-source-max-concurrent-reconciles\", \"2\",\n      ]\n  target:\n    name: controller-manager\n</code></pre>"},{"location":"usage/#metrics","title":"Metrics","text":"Metric Type Description <code>cmmc_resource_condition</code> <code>gauge</code> The current condition of the CMMC Resource. <code>cmmc_resource_sources</code> <code>gauge</code> Number of sources per resource. <p>You can add a Prometheus Monitor to scrape the metrics by adding <code>config/prometheus</code> to the list.</p>"},{"location":"usage/#custom-resources","title":"Custom Resources","text":"Resource Purpose <code>MergeTarget</code> Manages and validates a target ConfigMap docs <code>MergeSource</code> Watches source ConfigMaps for changes and accumulates their data docs"},{"location":"example/aws-auth/","title":"aws-auth","text":"<p>Let's build a solution for managing <code>kube-system/aws-auth</code>.</p>"},{"location":"example/aws-auth/#1-create-a-mergetarget","title":"1. Create a <code>MergeTarget</code>","text":"<p>A <code>MergeTarget</code> describes the target <code>ConfigMap</code> that want to write the data to.</p> <pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: config.cmmc.k8s.cash.app/v1beta1\nkind: MergeTarget\nmetadata:\n  name: kube-system-aws-auth\nspec:\n  target: kube-system/aws-auth\n  data:\n    mapRoles: {}\n    mapUsers: {}\nEOF\n</code></pre> <p>This says that we want to write/merge data to the <code>mapRoles</code> and <code>mapUsers</code> keys of <code>kube-system/aws-auth</code>. Note, there is no validation, or initial value for these keys in this example, but we can add this later on.</p>"},{"location":"example/aws-auth/#2-create-a-mergesource-for-maproles","title":"2. Create a <code>MergeSource</code> for <code>mapRoles</code>","text":"<p>A <code>MergeSource</code> describes what <code>ConfigMap</code>s we are watching to write to the <code>target</code>. This one specifically looks for ConfigMap resources with the label: <code>cmmc:k8s.cash.app/merge: \"aws-auth-map-roles\"</code>.</p> <p><code>target.name</code> refers to the <code>MergeTarget</code> we created earlier.</p> <pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: config.cmmc.k8s.cash.app/v1beta1\nkind: MergeSource\nmetadata:\n  name: aws-auth-map-roles\nspec:\n  selector:\n    cmmc.k8s.cash.app/merge: \"aws-auth-map-roles\"\n  source:\n    data: mapRoles\n  target:\n    name: kube-system-aws-auth\n    data: mapRoles\nEOF\n</code></pre>"},{"location":"example/aws-auth/#3-create-some-sample-configmap-sources","title":"3. Create some sample ConfigMap sources","text":"<p>Let's create a sample configuration for two services/namespaces, <code>service-a</code> and <code>service-b</code>, which need some role binding from AWS to K8S.</p> <pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: service-a\n---\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: service-b\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: aws-roles-mapping\n  namespace: service-a\n  labels:\n    cmmc.k8s.cash.app/merge: \"aws-auth-map-roles\"\ndata:\n  mapRoles: |\n    - rolearn: arn:aws:iam::111122223333:role/external-user-service-a\n      username: service-a-external\n      groups:\n      - service-a\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: aws-roles-mapping\n  namespace: service-b\n  labels:\n    cmmc.k8s.cash.app/merge: \"aws-auth-map-roles\"\ndata:\n  mapRoles: |\n    - rolearn: arn:aws:iam::111122223333:role/external-user-service-b\n      username: service-b-external\n      groups:\n      - service-b\nEOF\n</code></pre>"},{"location":"example/aws-auth/#4-check-the-resources","title":"4. Check the resources","text":""},{"location":"example/aws-auth/#target","title":"Target","text":"<pre><code>kubectl get cm -n kube-system aws-auth -o yaml\n</code></pre> <pre><code>apiVersion: v1\ndata:\n  mapRoles: |\n    - rolearn: arn:aws:iam::111122223333:role/external-user-service-b\n      username: service-b-external\n      groups:\n      - service-b\n    - rolearn: arn:aws:iam::111122223333:role/external-user-service-a\n      username: service-a-external\n      groups:\n      - service-a\nkind: ConfigMap\nmetadata:\n  annotations:\n    config.cmmc.k8s.cash.app/managed-by-merge-target: default/kube-system-aws-auth\n  name: aws-auth\n  namespace: kube-system\n</code></pre>"},{"location":"example/aws-auth/#statuses","title":"Statuses","text":"<pre><code># kubectl get mergetarget\nNAME                   TARGET                 READY   STATUS                         VALIDATION\nkube-system-aws-auth   kube-system/aws-auth   True    Target ConfigMap up to date.   1 MergeSources reporting valid data\n</code></pre> <pre><code># kubectl get mergesource\nNAME                 READY   STATUS\naws-auth-map-roles   True    Data from 2 ConfigMap(s)\n</code></pre>"},{"location":"example/aws-auth/#cleanup","title":"Cleanup","text":"<pre><code>kubectl delete ns service-a\nkubectl delete ns service-b\nkubectl delete mergesource aws-auth-map-roles\nkubectl delete mergetarget kube-system-aws-auth\n</code></pre>"},{"location":"example/jsonschema/","title":"aws-auth JSONSchema","text":"<p>These satisfy the kube-system/aws-auth definition for <code>mapUsers</code> and <code>mapRoles</code>.</p>"},{"location":"example/jsonschema/#maproles","title":"mapRoles","text":"<pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"aws-auth-map-roles\",\n  \"type\": \"array\",\n  \"items\": { \"$ref\": \"#/$defs/role\" },\n  \"$defs\": {\n    \"role\": {\n      \"type\": \"object\",\n      \"required\": [ \"rolearn\", \"username\", \"groups\" ],\n      \"properties\":  {\n        \"rolearn\": {\n          \"type\": \"string\",\n          \"pattern\": \"^arn:aws:iam::\\\\d+:role/.+\"\n        },\n        \"username\": { \"type\": \"string\" },\n        \"groups\": { \"type\": \"array\", \"items\": { \"type\": \"string\" } }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"example/jsonschema/#mapusers","title":"mapUsers","text":"<pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"aws-auth-map-users\",\n  \"type\": \"array\",\n  \"items\": { \"$ref\": \"#/$defs/user\" },\n  \"$defs\": {\n    \"user\": {\n      \"type\": \"object\",\n      \"required\": [ \"userarn\", \"username\", \"groups\" ],\n      \"properties\":  {\n        \"userarn\": {\n          \"type\": \"string\",\n          \"pattern\": \"^arn:aws:iam::\\\\d+:user/.+\"\n        },\n        \"username\": { \"type\": \"string\" },\n        \"groups\": { \"type\": \"array\", \"items\": { \"type\": \"string\" } }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"resources/mergesource/","title":"MergeSource","text":"<pre><code>apiVersion: config.cmmc.k8s.cash.app/v1beta1\nkind: MergeSource\nmetadata:\n  name: merge-map-roles-aws-auth\nspec:\n  selector:\n    cmmc.k8s.cash.app/merge: \"something\"\n  source:\n    data: someKey\n  target:\n    name: our-merge-target\n    data: someKey\n</code></pre> <ul> <li>A <code>MergeSource</code> describes what <code>ConfigMap</code> resource we are watching with its <code>selector</code> field.   So any <code>ConfigMap</code> with a label that matches <code>spec.selector</code> will be watched.</li> <li>The controller will read data from the <code>source.data</code> field on a matching <code>ConfigMap</code></li> <li>The <code>MergeSource</code> will annotate the watched CMs so they know they are being watched.</li> <li>This resource/controller does no mutatations of the data on any of the resources outside of   the annotation!</li> <li>Annotations are cleaned up when the resource is deleted.</li> <li>The MergeTarget at <code>spec.target.name</code> will watch for <code>MergeSource</code> resources with it as the target   and read their aggregated states to attempt to write to the target ConfigMap.</li> </ul>"},{"location":"resources/mergetarget/","title":"MergeTarget","text":"<pre><code>apiVersion: config.cmmc.k8s.cash.app/v1beta1\nkind: MergeTarget\nmetadata:\n  name: our-merge-target\nspec:\n  target: some-ns/some-resource-name # a configMap\n  data:\n    someKey:\n      init: ''\n      jsonSchema: |\n        { \u2026 }\n</code></pre> <ul> <li>A <code>MergeTarget</code> describes the resource we are managing, in this case it is <code>some-ns/some-resource-name</code>.</li> <li>We can configure this resource with the keys that we care about managing on the target, above   its <code>someKey</code>.</li> <li>Each <code>data[$key]</code></li> <li>Can have an initial value that we'll inject if the data was not present the key was missing or empty</li> <li>Can have an optional <code>jsonSchema</code> that we use to validate the data before it is persisted.</li> <li>Creates the ConfigMap if it doesn't exist.</li> <li>Uses annotations to make sure there is only one <code>MergeTarget</code> per <code>spec.target</code></li> <li>Clean up after itself when it is deleted.</li> <li>If it didn't eist, it will be removed</li> <li>If it did exist, the data will be reset back to what it was before.</li> </ul>"}]}